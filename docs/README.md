# Java script基础

一门运行在浏览器端（App）的脚本（剧本）编程（带逻辑思维学习）语言（实现交互）
注：里边的符号一定要用英文符号

## 基础

### 前端中的地位

- html   骨架
- css  皮肤样式
- Java script   行为   交互 

### 引入方式

- 外链式（开发使用）

  与link标签不同也是使用script标签：
  <!-- <script src="./02-demo.js"></script> -->

- 行内式（一般不用）

  div id="box" onclick='alert("你点击我了")'></div>

- 内嵌式（学习阶段）

  写在<body>标签下
  <script>    
  内容
  

  </script>

### 注释

- 单行注释

  // 1.单行注释：一般是用于简单的注释；阿达 阿萨达是多  ctrl + /

- 多行注释

  2.多行注释：大段落的注释，用于文档说明，后面函数方法的说明 ctrl + shift + /
    /*

### 输入&输出

- prompt  文本框

  弹出输入文本框：
  		prompt（提示输入信息）

- alert  弹窗

  弹出一个提示窗口。学习阶段使用：
   		alert（提示内容）

- console.log 后台输出

  控制台可见：
  	console.log（输出内容，多个内容{，}隔开）

- document.write  页面内输出

  可以在页面内输出：
  		document.write（<p>输入内容，也可以输入htm标签</p>“l）

### 变量  var

本质
变量接收，储存数据

- 语法

  1. var 关键字 声明变量
     var a; 声明变量；
     a = 1; 给变量赋值

- 配合输入

  var pwd = prompt('请输入您的卡密码')
  alert(pwd);

- 可以再次赋值

  var b = "我";
    console.log(b);
     再次重新赋值，以后b一直是200；
     b = 200;
     console.log(b)

- 声明时赋值

  5. 声明时赋值；
     var a = 1;
      = 后面有个东西要赋值给a
      a+1后结果，重新赋值给a;
     a = a + 1;
     自己运算后给自己重新赋值

- 命名规范

  1.不能数字开头
  2.不能用关键字 保留字
  3. 区分大小写
  4. 根据英文场景，一般用英文；
    5.驼峰：主要是为了你开发方便，推荐
  5. 个人习惯；

- 补充

  1.一行声明；
    var a,b;
   2.声明时赋值
    var a = 1;
    var b = 2;
    3. 声明的时候，也赋值；
        var a = 1,b = 2;
   4. 我们要一起声明；
      var a, b = 2;
      3.变量赋值给其他变量
      var a = 1;
       		 a = 2;
      var  b = 2;
       a 赋值给你a;
      b = a;

### 基本数据类型

现金和支付宝里u的数字都是在描述我们的资产，但他们类型不同

- 数字类型 nunber

  所有数字都是数字类型
  NaN   不确定的某个数     数字类型

- 字符串类型

  字符串：单双引号；
    var b = "1";
    我说："今天班长真好看！"
    单双引号：单引号包着双引号
    console.log('我说："今天班长真好看"');
    用双引号包着单引号；
    console.log("我说：'今天班长真好看'");
  转译字符：js可以认识的字符

- 布尔类型  boolean

  true    成立
  false  不成立

- null 值   复杂类型
- undefined 不知道的值

  浏览器懵了，意思是：
  它也不知道给你啥值！！

- 检查类型   typeof

  用法：
  1.typeof+空格+变量名；
  2..typeof（变量名）；

- 数据类型转换

  其他类型转数字类型：
  			Namber（其他数据类型）；
  Namber（字符串类型）；结果：NaN；
  Namber（布尔类型）；结果：true（1）
  false（0）；
  Namber（null）；结果：0   空
  ；
  Namber（undefined）；结果：NaN

  undefined 不知道给你啥值只能 NaN；
  -----------------------------------------------------
  parseInt(其他数据类型)，parseFloat(其他数据类型)：
  只能接受字符串,要转成功：必须字符串里的数字写在前面，其他类型都是  NaN
  -----------------------------------------------------
  其他类型转字符串类型：
  String（）:相当于给你要转的这个数据左右两边加单双引号；
  .toString():null undefined 不能用
  -----------------------------------------------------
  其他类型转布尔类型：
   转 Boolean 结果：存在 不存在 返回就是一个布尔值；
    // 逻辑：只要是确认的，存在的数据，都是ture
   6中情况转false ：
  空字符串、0 、 NaN、null、undefined、false

### 操作符

- 算术操作符

  1.常规操作：数字类型
   运算操作。优先级比赋值操作符高。
  2.非常规：字符、布尔、null、undefined；
  字符串遇见+，临近 的类型 变为字符串，拼接；
  只要字符串不遇见+,确认参与运算。
   要求数字类型
   不是数字类型，隐式转化数字类型的过程；
  var a = "1000" - 1;"1000" 可以转化为1000；
  ture+1=2
   不常规：

  字符串遇见+：左右临近的类型都会转换为字符串；
   字符串遇见- / * %：参与运算，我们要的数据类型，字符串隐式转换为数字类型
    数字  "1000"
  能成功转化
    NaN   "abc"  "null";
    null 隐式转数字 0
    Boolean 隐式转数字 0 或者1
    undefined 隐式转数字 NaN
  -----------------------------------------------------
  a++   先运算得结果，后自增；
  ++a   先自增  ，后运算得结果；

- 比较操作符

  比较运算符：> < >= <=
   常规操作：比数字类型
  返回:这个比较后的结果状态 Boolean；
   比较操作符 优先级高于 赋值操作符
   非常规：
   比较运算符：两边都是需要数字类型；
    不是数字类型， 隐式转化 为 数字类型；
  -------------------------------------------------------
   ==与===；
   ==:比较运算符，优先级高于 赋值运算符；
   1 先看类型:
   2若类型相同，比值；
   3.若类型不同，隐式转化 数字类型
  ；
   NaN:泛指，不是某个数；
   console.log(NaN == NaN);false
   ===：直接比类型，
   先看类型:
   1.如果类型相同，比值；
   2.如果类型不同，直接false;
  != !==：和上面是同理，只不过是判断数据的值不等；

- 逻辑操作符

  && 且 ：全部满足 
    常规：需要Boolean值进行逻辑判断；
    返回：把最后一个满足的结果，返回过来；
    console.log(true && true);
    返回：当遇见不满足情况，直接就把不满足结果返回；
    console.log(false && true);
    遇见：非Boolean值；转换为布尔值参与逻辑判断；
    console.log(1 && 2);
    true  true  返回最后那个是true判断的结果；
     console.log(null && 1);
     转化 只是去参与比较:false true;
    返回：原来位置上的数据；
  -----------------------------------------------------
   || 或：满足一个条件即可；

- 赋值运算符

  配合算术运算符在里面；简写：
  +=  -=  *=  /=  %=
  a = a % 3;
  简写：
  a %=3;

- 操作符优先级

  大致的优先级：
  - 括号先算
  - 其次算算术：++a优先;
  - 再次算比较  > ==
  - 然后算逻辑 && ||
  - 最后算赋值 =

## 结构

### 流程控制

	- 表达式
	
	  在js代码中，只要可以返回一个**结果**的，都可以称为一个表达式；
	  技巧：在浏览器后台可以直接敲表达式，回车返回的就是该表达式的结果
	
	- 语句
	
	  - 可以理解为一个**行为**，一般在行为和行为之间，都会使用 `;` 隔开。
	  - 行为：告诉浏览器，我要干什么，你按照我写的思路，给我实现出来给用户看；
	  - 可以理解为：**语句，是有思维参与在里面的表达式，升级版的表达式；**
	  - 语句有时候会有返回值，有时候就没有；更侧重是一个**行为上**的理解；
	
	- 结构
	
	  写程序，就是写各种**语句的组织**，归根到底，就是各种表达式参与我们的思维的体现
	  - - 顺序结构：从上到下执行的代码就是顺序结构，**程序默认就是由上到下顺序执行的**；
	    - 分支结构：不同的情况下，走不同的分支；
	    - 循环结构：重复做一件事情，其作用就是用来重复执行代码的；
	  - **程序的世界中大量的逻辑就是 分支和循环；**

### 结构

- 分支结构

  - if结构

    if语句：我想看条件表达式的结果成立时，会怎么样；
    // 条件表达式：需要返回Boolean值；如果返回的不是Boolean值，就隐式转化为Boolean值；
    if(true) {
       // 当 条件表达式 的结果是 true 时 执行的代码
    if(条件表达式){
       //当条件表达式的结果是 true 时执行的代码
    }else {
      //当条件表达式的结果是 false 时执行的代码
    }

    -----------------------------------------------------
    if-else-if**：解决多分支的判断问题
    // 当满足这个
    if(条件表达式1){
       //当条件表达式1的结果是 true 时执行的代码
    }
    else if(条件表达式2){
      //当条件表达式2的结果是 true 时执行的代码
    }
    else if(条件表达式3){
      //当条件表达式3的结果是 true 时执行的代码
    }
    // 中间可以继续写多个判断 ...
    else {
      // 多个条件表达式的结果都是 false 的时候执行的代码
    }

  - switch-case结构

    switch-case结构：主要用于多个**固定值**之间的判断，只能做固定值的判断
    switch （数据）{
      case 固定值1: 
        // 当 数据 === 固定值1 时执行的代码; 先看类型，看值；
        
        // 表示当前 情况结束；
        break;

      case 固定值2: 
        // 当数据 === 固定值2时执行的代码;
        break;
            
      case 固定值3: 
        // 当数据 === 固定值3时执行的代码;
        break;
      // 中间还可以写多个判断


      default : 
        // 当数据和上面的所有固定值都不相等的时候执行的代码
        break;
    }

  - 三元表达式

    表达式：**有值会返回；**
    语法：if else 的简写；有返回值；
    表达式1 ? 表达式2 : 表达式3;

    // 首先 要知道 表达式 会返回结果；
    // 先执行表达式1，判断其结果是true还是false，
    // 如果是true，则执行表达式2，然后将 表达式2的执行结果 作为整个三元表达式的结果，
    // 如果是false，则执行表达式3，并 表达式3的结果 作为整个三元表达式的结果

- 循环结构

  - while循环

    语法：
     条件表达式结果返回布尔值；true;
    while (条件表达式){
      // 循环体  就是重复执行的代码
    }
    - 特点：
      - 设置为true，容易卡死；
      - 设置false，直接就不执行；
    - 直接写true false直接就玩死：
      初始化变量
      var num = 1;

    // 退出条件：
    while(num<=10) {
        // 循环体：过程，你想要重复的事情；这样里面就循环了十次
        
        
        // 满足退出条件的代码
        num++;
    }
    // 写这种可以配合着循环变化的表达式（先成立，最后不成立）
    -----------------------------------------------------
    - 执行过程：
      - 1.**先执行条件表达式，得到一个布尔类型的结果**
      - 2.如果表达式的结果为false，循环结束，不执行循环后面的代码
      - 3.如果表达式的结果为true，执行循环体；
      - 4.重复1~3的过程，直到表达式结果为false，结束循环；
    - 找偶数：
      - 1-10的数据一个个的过；
      - 每个数据要经过 偶数条件 的筛查；

  - for循环！！！

    语法；
    for(初始化表达式; 条件表达式; 自增表达式){
      // 循环体
    }
    - 执行过程：

    1. **执行初始化表达式(只执行一次)**
    2. **执行条件表达式**
    3. 如果条件表达式的结果为false, 结束循环；
    4. 如果条件表达式的结果为true，执行循环体
    5. **执行自增表达式**
    6. 重复2~5的步骤，直到条件表达式的结果为false，结束循环

  - do-while循环(补充)

    语法；
    do {
      //循环体
    }while(条件表达式)
    - 执行过程：
      - 先执行循环体
      - 执行条件表达式
      - 如果条件表达式结果为false，结束循环
      - 如果条件表达式结果为true，执行循环体
      - 重复2~4的步骤，直到条件表达式结果为false，结束循环
    - 特点：
      - 至少会执行一次；
      - 写true也会卡死；

- 调试 

  在逻辑复杂情况下在后台调试分析；
  1.在浏览器页面，右击鼠标点击检查进入后台
  2.再结构页面点击Sources进入调试页面
  3.在想要观看演示的地方点击建立断点
  4.点击右上角从左至右第一个按钮；
  5.再点击页面刷新
  6.点击右上角从左至右第三个按钮 “下一步”进行观看演示。

## 数组

### 数组

数组：
	数据是一个有顺序、有长度数据集合。
数组类型；Object；
特点：
- 把数据放在一起；
- 有先后位置上的顺序；
- 有数据的长度；

- 声明

  声明;
  var  arr =[数据，数据 ]这是一个数组。
  没有数据的数组称为空数组。

- 存值

  把数据存到数组里；
  arr[0] = 91;
  arr[1] = 88;
  arr[2] = 72;
  arr[3] = 45;
  arr[4] = 63;
  这时数组里应该是：
  var  arr=[91,88,72,45, 63]

- 取值

  把存进去的数据取出来；
  arr[0]  是数组里的第一个值，那第一个数据的索引（又称下标）为0；把索引当一个变量用就好；数组的索引是从0开始的。

- 数组长度  length

  数组长度就是数组里数据的个数；
  表示方法；
  		数组名.length=数据的个数；
  数组长度往往比索引大1。

- 遍历

  var  arr=[数据、、、、]  先声明一个数组，
  var sum = 0;一个承接和的变量
  for(var i = 0; i <arr.length(数组长度） ; i++){
    sum += arr[i];i同时也是索引数值，
  让它们都经过一遍，累积相加。
  }
  console.log(sum);最后的结果

- 清空数组

  arr.length=0;

- 数组构造函数

  语法：
  	var  arr = new Array();
  和数组的区别：
  	输入多组数时没啥区别，但是只输入一组数据时，数组会把这一组数当成其中一组数据
  而构造函数则会把它当做长度使用
  *注意  函数后边跟着（）而数组后边跟着[ ];

### 小娜V1.0知识点

- 循环结构知识点

  当遇到未知循环次数时用  while循环或者do while循环

- 分支结构知识点

  break；循环退出，这里switch分支结构里边break重复不生效，所以不用，但也是可以使用：

- 求和知识点

  需求：我们输入"数字,数字,数字"的格式，需要转为数组，求和。
  当我们输入数字时，就会出现以下情况；
  var str = '12,88,72,6'
  这时候不是只要转数字类型就可以，需要用分隔符；
  语法：
  		var str = '12,88,72,6'
  转换：
  		var str = str.split(',');这时候就把它转换成一个从前到后的数组了。
  		var  str = [12,88,72,6]
  再按照数组求和运算即可。
  注; 括号里的分割符和你要求的符号必须一致。

- 获取时间知识点

  在js中，要获取系统的当前日期和时间，需要用到一个js自带的**Date对象** ：
  	创建Date对象：
  	var date = new Date();必须写
  	获取年份：
  	var year = date.getFullYear();
  	获取月份 ：
  	var month = date.getMonth();
  	获取天：
  	var day = date.getDate();
  	注：这里day在国外是指星期天，后边必				须是date才能获取日。
  	获取小时
  	var hour = date.getHours();
  	获取分钟
  	var minute = date.getMinutes();
  	获取秒数
  	var second = date.getSeconds();
  	为了格式上的好看：单位数，补位成双位数；
  	if(day < 10){
      day = '0' + day;
  }

- 随机笑话知识点

  有给随机值的一个对象Math：
  语法：	var r = Math.random();（默认是选取0~1之间的随机数。
  如果想要得到一个随机整数，需要把整机浮点数  乘以 一个 倍数，再取整，
  	var r = Math.random() * 10;
  	var index = Math.random(); [0,1)
  	index *= list.length ; // [0,5)
  最后一条永远拿不到，让最后一个笑话为空；
  index = Math.floor(index) 向下取值;  [0,4]
  	alert（数组名[ index ]）

- 字符串拼接补充

  alert（tab上边的反点：包裹`字符串在外${变量值在里}`）

## 函数

### 函数

函数：我们**把一段相对独立的具有特定功能的代码块封装起来**，形成一个**独立实体**，起个名字（函数名），在后续开发中可以**随时反复调用**
	作用：
	封装（包起来）一段代码，将来可以随时拿来使用
	封装：功能要单一！！！

- 语法

  使用：
  	function 关键字 用于声明函数，
  	function 函数名（形参）{
  		里面叫函数体：我们封装，我们想随时随地拿来使用的东西
  		}
  	形参：它只是给里边要变的数据定义的名字，与实参没有一点关系，只是获取函数时实参顶替的位子，带入函数进行运行。
  	注：取函数名不能数字开头,不能用关键字 保留字

- 调用

  调用：声明的函数，一段代码被包起来；需要被调用，才能执行当前的函数 不调用永不执行；
  	tellStroy(实参)

- 函数表达式

  1.js中声明函数的方式不只有一种，还有一种方式叫`函数表达式`；
  2.声明变量，赋值为函数；

- 匿名函数

  匿名函数：没有名字的函数，但是在js的语法中，是不允许匿名函数单独存在的，要配合其它语法使用：
  		先定义一个匿名函数，再用一个变量承接，这时候那个变量名就是函数名。
  	自调用函数：自调用函数（自执行函数）：匿名函数的另外一种使用方法；很多时候，我们需要加载页面后，自动执行一个函数；

- 函数类型

  在js中，只要是一种数据类型的，都可以作为函数的参数**，

### 参数

对于函数来说，参数是函数里边的一个变量。

- 配置参数

  function 函数名（参数）{

  	把你要替换的部分替换为参数。
  		}
  配置多个参数：
  		 函数名（参数1，参数2，参数n）{		函数体			}
  	记得要把配置的参数写入函数名后边的（）
  	调用：
  		 函数名（实际参数）；
  	在函数调用的时候，传入一个实际要参与的变量值

- 参数不赋值

  如果参数不赋值，那么他就变为undefined；
  	undefined：系统也不知道给你什么值的值。
  	严谨写法：
  （三元表达式）：参数 =参数?参数：默认参数；
  	1.如果没有参数输入时；就应该给它手动添加一个默认参数；
  	2.当没有输入参数时，undefined=undefined，返回的值是布尔值false，执行冒号后边的默认参数，如果有值时返回的是true，则执行？后边的自己。

- 形参与实参

  形参： 形式上的参数，只能在内部使用。
  	实参：真正参与运算的参数，可以为外边定义好的变量，且互不影响。
  函数调用变量进行运算互不影响，函数只是借了变量背后的值进行运算，不会影响外边的变量。

- 返回值  return

  1.返回值：return 用于返回一个函数内部的值，后边必须跟值，不跟值返回undfind。
  		return+空格+函数里要返回的值（写在函数内部。
  2.终止函数执行
  	在函数内部加入return，那么return后边的函数将不会在执行。

- 函数内置  arguments伪数组

  arguments：获取所有实参的对象，函数内部的变量（不是我们声明的，也不需要我们声明）。
  arguments 这个东西看起来样子像数组，但是其实不是一个数组，我们管它叫 `伪数组`。它具有数组的长度和顺序等特征。本质为对象，可以循环遍历。
  理解：
     当我们不知道参数为几个时，我们可以用函数时，随便定义实参，这时候函数里边的伪数组arguments就会帮我们自动把那些参数存为一个以“arguments”命名的函数内部的数组。

### 补充

- 回调函数

  函数也是数据类型，也可以作为别的函数的参数
  	fn 只不过在函数内部是一个形参，内部变量；
  function f1(a,fn){
    console.log(a);
   函数的调用，在函数名的后面加括号；
   内部的函数对外面的函数叫回调函数；
    fn(); 
  }

  function f2(){
    console.log('f2函数执行了');
  }
  f1(10,f2);// 输出 10 和 'f2函数执行了'

   像这种作为函数的参数，并在之内调用的函数，我们称为 `回调函数`；

- 预解析！！

  预解析：提前、解析（分析）会把**初始化的声明的变量、函数**，全部提升到**当前作用域**的最顶端；置顶！！
  	变量：已经声明；函数：已经声明；
    但是而变量的赋值和函数的调用还在原来的位置！！
  	所以下边声明变量时，上边解析变量将会是一个空变量，并没有赋值的变量。

- 作用域！！

  作用域：作用范围，能生效的范围；
  全局：
    	全局作用域：能在页面的任何位置都可以访问。<script>标签以内的作用域
    	全局变量：在全局作用哉下声明的变量；
  	局部：
    	局部作用域：只能在局部的作用域范围进行访问；函数里的作用域。
    	局部变量：在局部作用域下声明的变量；

## 对象

### 介绍

核心概念：**万物皆对象**，我们在编程中，使用对象来描述万事万物。
* 对象：使用`属性`描述事物的`特征`，使用`方法`来描述`行为`， 就是对象这种语法。所以，对象就是属性和方法的集合
* 对象描述扳手：
  - 属性：金属、银白色
  - 方法：能拧螺丝、防身等；

### 面向对象思想

我们不需要关心随机数到底是怎么产生的，只要结果
面向对象思想：找一个**对象（工具）**，看它身上有什么方法和特点，然后我就可以用这个工具，按照我们的思维安排这个工具做事件就可以。
 特点：
  * **实现高效开发**：我们只要知道对象（工具）有什么属性和方法，不需要知道对象里面是如何实现的。**在别人已经提供好的方法的基础上，再次实现我们想要的效果，开发过程将大大缩短。**
  * **便于维护：**因为你是单个对象（工具），我可以随时对你进行改造，修改；满足我的需要；

### 语法

- 创建

  方法1：
  	var obj（对象名称） = new Object(); // 这是一个没有属性和方法的对象
  	方法2：
  	var obj = {}; // 这也是一个没有属性和方法对象，其本质和构造函数创建的对象是一样的

- 添加属性

  // 2.添加属性（特征）
    // 语法：对象.属性的名称 = 属性值（特征的值）
    // 属性的名称：根据你的业务需求自己命名的；
    obj.name = "狗蛋";
  // 3.添加方法：
    // 语法 对象.方法名 = 函数(匿名函数)
    // 函数什么时候才会执行？调用的时候才会执行；
    obj.say_name = function() {
      console.log(obj.name);
    }7
  / 如果一开始，你知道对象内部的属性和方法，初始化声明
    var obj = {
      // 语法：属性名:属性值
      // 多个属性名和值之间用, 隔开；
      name: "狗蛋",
      // 
      age: 12,
      // 方法名:函数
      sayName: function() {
        console.log(obj.name);
      }
    };
   // 声明方式：键值对的方式声明；
  	属性名必须是字符串
    // 语法：对象["属性名"]  = 属性值；

    var obj = {};

    obj["name"] = "狗蛋";
    obj["age"] = 45;

- 获取j及遍历属性

  `js
    // 获取：点的方式；
    // console.log(obj.name);
    // 键的方式
    // console.log(obj["name"], obj.age);


    // 添加属性和获取属性的语法方式不同，不是说哪个方式的添加就必须用哪个方式的获取；
  ```
  
  * 补充：打印一个对象上没有的属性名，返回值undefined；
   遍历：
  
  ```js
    // 遍历：数组遍历（循环）
    // 遍历：对象遍历（对象上这些方法一个个过一次，也是某种意义上的循环）
    // key：泛指 代表 对象上的每对键值对的 键；
    for (var key in obj) {
      // console.log(key);
  
      // 获取方式：
      // 点方式：obj.key 为什么会输出 undefined；
      // 把obj.key 这个key 当做一个属性名；
      // console.log(obj.key);
  
      // ["属性名"]
      // console.log(obj[key]);
  
      console.log(key, obj[key]);
  
    }
  ```

### 其他

- 对象-拓展Math的n-m的随机整数

  * 语法：
    * 1.实现具体过程；
    * 2.抽象为函数
    * 3.给Math添加一个方法；

  ```js
    // 3.拓展Math新的方法
    Math.getRandom = function(n, m) {
      var res = Math.random() * (m - n + 1);
      // 向下取整 [0,m-n]
      res = Math.floor(res);
  
  
      // res [0,40];  加10之前；
      res = res + n;
  
      // res [10,50];
      // console.log(res);
      // 
      return res;
    }
  ```

- 简单类型与复杂类型储存数据的区别

  简单类型：
  var a = 1;
  var b = a; 把a的值附b上；
  	  b = 3; 给b重新附值；
  console.log(a,b)  得到的是 a=1  b=3;
  栈：理解·：a和b是简单类型，可以把这个“栈”看作一个宾馆；
  声明 a和b就相当于a和b这两个”人“在“栈”这个宾馆里
  开了两个房，a赋值就是a给a开的房子放了一些东西。给b赋值a，就是
  把a放在屋子里的东西再复制一份，b重新赋值就是把复制a的东西覆盖
  掉成为新的东西，所以它俩互不影响。
  复杂类型：

## 内置对象

*XMind: ZEN - Trial Version*